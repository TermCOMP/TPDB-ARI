; @origtpdbfilename Frederiksen_Others/strmatch.tml.trs
; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/Frederiksen_Others/strmatch.xml"
(format TRS)
(fun domatch[Ite] 4)
(fun True 0)
(fun strmatch 2)
(fun prefix 2)
(fun Nil 0)
(fun and 2)
(fun eqNatList[Ite] 5)
(fun !EQ 2)
(fun S 1)
(fun Cons 2)
(fun 0 0)
(fun notEmpty 1)
(fun eqNatList 2)
(fun domatch 3)
(fun False 0)
(rule (prefix (Cons x' xs') (Cons x xs)) (and (!EQ x' x) (prefix xs' xs)))
(rule (domatch (Cons x xs) Nil n) Nil)
(rule (domatch Nil Nil n) (Cons n Nil))
(rule (prefix (Cons x xs) Nil) False)
(rule (prefix Nil cs) True)
(rule (domatch patcs (Cons x xs) n) (domatch[Ite] (prefix patcs (Cons x xs)) patcs (Cons x xs) n))
(rule (eqNatList (Cons x xs) (Cons y ys)) (eqNatList[Ite] (!EQ x y) y ys x xs))
(rule (eqNatList (Cons x xs) Nil) False)
(rule (eqNatList Nil (Cons y ys)) False)
(rule (eqNatList Nil Nil) True)
(rule (notEmpty (Cons x xs)) True)
(rule (notEmpty Nil) False)
(rule (strmatch patstr str) (domatch patstr str Nil))
(rule (and False False) False :cost 0)
(rule (and True False) False :cost 0)
(rule (and False True) False :cost 0)
(rule (and True True) True :cost 0)
(rule (!EQ (S x) (S y)) (!EQ x y) :cost 0)
(rule (!EQ 0 (S y)) False :cost 0)
(rule (!EQ (S x) 0) False :cost 0)
(rule (!EQ 0 0) True :cost 0)
(rule (domatch[Ite] False patcs (Cons x xs) n) (domatch patcs xs (Cons n (Cons Nil Nil))) :cost 0)
(rule (domatch[Ite] True patcs (Cons x xs) n) (Cons n (domatch patcs xs (Cons n (Cons Nil Nil)))) :cost 0)
(rule (eqNatList[Ite] False y ys x xs) False :cost 0)
(rule (eqNatList[Ite] True y ys x xs) (eqNatList xs ys) :cost 0)
