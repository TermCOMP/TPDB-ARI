; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/Frederiksen_Glenstrup/parsexp.xml"
(format TRS)
(fun Plus 0)
(fun LPar 0)
(fun True 0)
(fun head 1)
(fun factor 1)
(fun Minus 0)
(fun atom 1)
(fun expr 1)
(fun |expr[Let]| 2)
(fun Div 0)
(fun Mul 0)
(fun member 2)
(fun !EQ 2)
(fun Cons 2)
(fun |term[Let][Ite][False][Ite]| 3)
(fun Val 1)
(fun False 0)
(fun term 1)
(fun |factor[Ite][True][Let]| 2)
(fun |member[Ite][True][Ite]| 3)
(fun Nil 0)
(fun and 2)
(fun |factor[Ite][True][Let][Ite]| 3)
(fun RPar 0)
(fun S 1)
(fun |term[Let]| 2)
(fun |expr[Let][Ite][False][Ite]| 3)
(fun |0| 0)
(fun eqAlph 2)
(fun notEmpty 1)
(fun parsexp 1)
(rule (head (Cons x xs)) x)
(rule (factor (Cons RPar xs)) xs)
(rule (factor (Cons Div xs)) xs)
(rule (factor (Cons Mul xs)) xs)
(rule (factor (Cons Plus xs)) xs)
(rule (factor (Cons Minus xs)) xs)
(rule (factor (Cons (Val int) xs)) xs)
(rule (factor (Cons LPar xs)) (|factor[Ite][True][Let]| (Cons LPar xs) (expr (Cons LPar xs))))
(rule (member |x'| (Cons x xs)) (|member[Ite][True][Ite]| (eqAlph x |x'|) |x'| (Cons x xs)))
(rule (member x Nil) False)
(rule (atom (Cons x xs)) xs)
(rule (atom Nil) Nil)
(rule (eqAlph RPar RPar) True)
(rule (eqAlph RPar LPar) False)
(rule (eqAlph RPar Div) False)
(rule (eqAlph RPar Mul) False)
(rule (eqAlph RPar Plus) False)
(rule (eqAlph RPar Minus) False)
(rule (eqAlph RPar (Val int2)) False)
(rule (eqAlph LPar RPar) False)
(rule (eqAlph LPar LPar) True)
(rule (eqAlph LPar Div) False)
(rule (eqAlph LPar Mul) False)
(rule (eqAlph LPar Plus) False)
(rule (eqAlph LPar Minus) False)
(rule (eqAlph LPar (Val int2)) False)
(rule (eqAlph Div RPar) False)
(rule (eqAlph Div LPar) False)
(rule (eqAlph Div Div) True)
(rule (eqAlph Div Mul) False)
(rule (eqAlph Div Plus) False)
(rule (eqAlph Div Minus) False)
(rule (eqAlph Div (Val int2)) False)
(rule (eqAlph Mul RPar) False)
(rule (eqAlph Mul LPar) False)
(rule (eqAlph Mul Div) False)
(rule (eqAlph Mul Mul) True)
(rule (eqAlph Mul Plus) False)
(rule (eqAlph Mul Minus) False)
(rule (eqAlph Mul (Val int2)) False)
(rule (eqAlph Plus RPar) False)
(rule (eqAlph Plus LPar) False)
(rule (eqAlph Plus Div) False)
(rule (eqAlph Plus Mul) False)
(rule (eqAlph Plus Plus) True)
(rule (eqAlph Plus Minus) False)
(rule (eqAlph Plus (Val int2)) False)
(rule (eqAlph Minus RPar) False)
(rule (eqAlph Minus LPar) False)
(rule (eqAlph Minus Div) False)
(rule (eqAlph Minus Mul) False)
(rule (eqAlph Minus Plus) False)
(rule (eqAlph Minus Minus) True)
(rule (eqAlph Minus (Val int2)) False)
(rule (eqAlph (Val int) RPar) False)
(rule (eqAlph (Val int) LPar) False)
(rule (eqAlph (Val int) Div) False)
(rule (eqAlph (Val int) Mul) False)
(rule (eqAlph (Val int) Plus) False)
(rule (eqAlph (Val int) Minus) False)
(rule (eqAlph (Val int) (Val int2)) (!EQ int2 int))
(rule (notEmpty (Cons x xs)) True)
(rule (notEmpty Nil) False)
(rule (term xs) (|term[Let]| xs (factor xs)))
(rule (parsexp xs) (expr xs))
(rule (expr xs) (|expr[Let]| xs (term xs)))
(rule (and False False) False :cost 0)
(rule (and True False) False :cost 0)
(rule (and False True) False :cost 0)
(rule (and True True) True :cost 0)
(rule (!EQ (S x) (S y)) (!EQ x y) :cost 0)
(rule (!EQ |0| (S y)) False :cost 0)
(rule (!EQ (S x) |0|) False :cost 0)
(rule (!EQ |0| |0|) True :cost 0)
(rule (|factor[Ite][True][Let]| |xs'| (Cons RPar xs)) (|factor[Ite][True][Let][Ite]| True |xs'| (Cons RPar xs)) :cost 0)
(rule (|factor[Ite][True][Let]| |xs'| (Cons LPar xs)) (|factor[Ite][True][Let][Ite]| False |xs'| (Cons LPar xs)) :cost 0)
(rule (|factor[Ite][True][Let]| |xs'| (Cons Div xs)) (|factor[Ite][True][Let][Ite]| False |xs'| (Cons Div xs)) :cost 0)
(rule (|factor[Ite][True][Let]| |xs'| (Cons Mul xs)) (|factor[Ite][True][Let][Ite]| False |xs'| (Cons Mul xs)) :cost 0)
(rule (|factor[Ite][True][Let]| |xs'| (Cons Plus xs)) (|factor[Ite][True][Let][Ite]| False |xs'| (Cons Plus xs)) :cost 0)
(rule (|factor[Ite][True][Let]| |xs'| (Cons Minus xs)) (|factor[Ite][True][Let][Ite]| False |xs'| (Cons Minus xs)) :cost 0)
(rule (|factor[Ite][True][Let]| |xs'| (Cons (Val int) xs)) (|factor[Ite][True][Let][Ite]| False |xs'| (Cons (Val int) xs)) :cost 0)
(rule (|term[Let]| |xs'| (Cons x xs)) (|term[Let][Ite][False][Ite]| (member x (Cons Mul (Cons Div Nil))) |xs'| (Cons x xs)) :cost 0)
(rule (|expr[Let]| |xs'| (Cons x xs)) (|expr[Let][Ite][False][Ite]| (member x (Cons Plus (Cons Minus Nil))) |xs'| (Cons x xs)) :cost 0)
(rule (|term[Let]| xs Nil) Nil :cost 0)
(rule (|member[Ite][True][Ite]| False |x'| (Cons x xs)) (member |x'| xs) :cost 0)
(rule (|factor[Ite][True][Let]| xs Nil) (|factor[Ite][True][Let][Ite]| (and False (eqAlph (head Nil) RPar)) xs Nil) :cost 0)
(rule (|expr[Let]| xs Nil) Nil :cost 0)
(rule (|member[Ite][True][Ite]| True x xs) True :cost 0)
