; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/Frederiksen_Glenstrup/vangelder_typed.xml"
(format TRS)
(fun r 2)
(fun True 0)
(fun head 1)
(fun t[Ite] 3)
(fun equal 2)
(fun e[Match][Cons][Ite][True][Match] 3)
(fun Cons 2)
(fun B 0)
(fun e 2)
(fun goal 2)
(fun False 0)
(fun p[Ite] 3)
(fun p 2)
(fun q[Ite][False][Ite] 3)
(fun q[Ite][False][Ite][True][Ite] 3)
(fun t 2)
(fun Nil 0)
(fun r[Ite][False][Ite][True][Ite] 3)
(fun q[Ite] 3)
(fun A 0)
(fun r[Ite] 3)
(fun and 2)
(fun q 2)
(fun T 0)
(fun notEmpty 1)
(fun F 0)
(rule (head (Cons x xs)) x)
(rule (e (Cons F Nil) b) False)
(rule (e (Cons T Nil) b) False)
(rule (e (Cons B Nil) b) False)
(rule (e (Cons A Nil) b) (e[Match][Cons][Ite][True][Match] A Nil b))
(rule (e (Cons F (Cons x xs)) b) False)
(rule (e (Cons T (Cons x xs)) b) False)
(rule (e (Cons B (Cons x xs)) b) False)
(rule (e (Cons A (Cons x xs)) b) False)
(rule (equal F F) True)
(rule (equal F T) False)
(rule (equal F B) False)
(rule (equal F A) False)
(rule (equal T F) False)
(rule (equal T T) True)
(rule (equal T B) False)
(rule (equal T A) False)
(rule (equal B F) False)
(rule (equal B T) False)
(rule (equal B B) True)
(rule (equal B A) False)
(rule (equal A F) False)
(rule (equal A T) False)
(rule (equal A B) False)
(rule (equal A A) True)
(rule (notEmpty (Cons x xs)) True)
(rule (notEmpty Nil) False)
(rule (e Nil b) False)
(rule (t x y) (t[Ite] (e x y) x y))
(rule (r x y) (r[Ite] (e x y) x y))
(rule (q x y) (q[Ite] (e x y) x y))
(rule (p x y) (p[Ite] (e x y) x y))
(rule (goal x y) (q x y))
(rule (and False False) False :cost 0)
(rule (and True False) False :cost 0)
(rule (and False True) False :cost 0)
(rule (and True True) True :cost 0)
(rule (q[Ite] False x' (Cons F (Cons F xs))) (q[Ite][False][Ite][True][Ite] (and (p x' (Cons F (Cons F xs))) (q x' (Cons F xs))) x' (Cons F (Cons F xs))) :cost 0)
(rule (q[Ite] False x (Cons F (Cons T xs))) False :cost 0)
(rule (q[Ite] False x (Cons F (Cons B xs))) False :cost 0)
(rule (q[Ite] False x (Cons F (Cons A xs))) False :cost 0)
(rule (q[Ite] False x (Cons T (Cons F xs))) False :cost 0)
(rule (q[Ite] False x (Cons T (Cons T xs))) False :cost 0)
(rule (q[Ite] False x (Cons T (Cons B xs))) False :cost 0)
(rule (q[Ite] False x (Cons T (Cons A xs))) False :cost 0)
(rule (q[Ite] False x (Cons B (Cons F xs))) False :cost 0)
(rule (q[Ite] False x (Cons B (Cons T xs))) False :cost 0)
(rule (q[Ite] False x (Cons B (Cons B xs))) False :cost 0)
(rule (q[Ite] False x (Cons B (Cons A xs))) False :cost 0)
(rule (q[Ite] False x (Cons A (Cons F xs))) False :cost 0)
(rule (q[Ite] False x (Cons A (Cons T xs))) False :cost 0)
(rule (q[Ite] False x (Cons A (Cons B xs))) False :cost 0)
(rule (q[Ite] False x (Cons A (Cons A xs))) False :cost 0)
(rule (q[Ite] False x' (Cons F Nil)) (q[Ite][False][Ite] (and True (and True (and False (equal (head Nil) F)))) x' (Cons F Nil)) :cost 0)
(rule (q[Ite] False x' (Cons T Nil)) (q[Ite][False][Ite] (and True (and False (and False (equal (head Nil) F)))) x' (Cons T Nil)) :cost 0)
(rule (q[Ite] False x' (Cons B Nil)) (q[Ite][False][Ite] (and True (and False (and False (equal (head Nil) F)))) x' (Cons B Nil)) :cost 0)
(rule (q[Ite] False x' (Cons A Nil)) (q[Ite][False][Ite] (and True (and False (and False (equal (head Nil) F)))) x' (Cons A Nil)) :cost 0)
(rule (r[Ite] False x' (Cons F xs)) (r[Ite][False][Ite][True][Ite] (and (q x' xs) (r x' xs)) x' (Cons F xs)) :cost 0)
(rule (r[Ite] False x (Cons T xs)) False :cost 0)
(rule (r[Ite] False x (Cons B xs)) False :cost 0)
(rule (r[Ite] False x (Cons A xs)) False :cost 0)
(rule (p[Ite] False x' (Cons F xs)) (and (r x' (Cons F xs)) (p x' xs)) :cost 0)
(rule (p[Ite] False x (Cons T xs)) False :cost 0)
(rule (p[Ite] False x (Cons B xs)) False :cost 0)
(rule (p[Ite] False x (Cons A xs)) False :cost 0)
(rule (q[Ite][False][Ite] True x' (Cons x xs)) (q[Ite][False][Ite][True][Ite] (and (p x' (Cons x xs)) (q x' xs)) x' (Cons x xs)) :cost 0)
(rule (t[Ite] False x y) True :cost 0)
(rule (t[Ite] True x y) True :cost 0)
(rule (r[Ite] True x y) True :cost 0)
(rule (q[Ite] True x y) True :cost 0)
(rule (q[Ite][False][Ite] False x y) False :cost 0)
(rule (p[Ite] True x y) True :cost 0)
