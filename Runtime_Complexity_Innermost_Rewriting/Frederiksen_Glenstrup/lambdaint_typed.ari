; @origtpdbfilename Frederiksen_Glenstrup/lambdaint_typed.tml.trs
; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/Frederiksen_Glenstrup/lambdaint_typed.xml"
(format TRS)
(fun App 2)
(fun True 0)
(fun red[Let] 2)
(fun red[Let][Let] 3)
(fun lambody 1)
(fun isvar 1)
(fun !EQ 2)
(fun subst[Ite] 4)
(fun lambdaint 1)
(fun eqTerm 2)
(fun subst[True][Ite] 4)
(fun red 1)
(fun mklam 2)
(fun False 0)
(fun mkapp 2)
(fun V 1)
(fun subst 3)
(fun and 2)
(fun appe2 1)
(fun lamvar 1)
(fun appe1 1)
(fun Lam 2)
(fun S 1)
(fun 0 0)
(fun islam 1)
(rule (subst x a (App e1 e2)) (mkapp (subst x a e1) (subst x a e2)))
(rule (subst x a (Lam var exp)) (subst[True][Ite] (eqTerm x (V var)) x a (Lam var exp)))
(rule (red (App e1 e2)) (red[Let] (App e1 e2) (red e1)))
(rule (red (Lam int term)) (Lam int term))
(rule (subst x a (V int)) (subst[Ite] (eqTerm x (V int)) x a (V int)))
(rule (red (V int)) (V int))
(rule (eqTerm (App t11 t12) (App t21 t22)) (and (eqTerm t11 t21) (eqTerm t12 t22)))
(rule (eqTerm (App t11 t12) (Lam i2 l2)) False)
(rule (eqTerm (App t11 t12) (V v2)) False)
(rule (eqTerm (Lam i1 l1) (App t21 t22)) False)
(rule (eqTerm (Lam i1 l1) (Lam i2 l2)) (and (!EQ i1 i2) (eqTerm l1 l2)))
(rule (eqTerm (Lam i1 l1) (V v2)) False)
(rule (eqTerm (V v1) (App t21 t22)) False)
(rule (eqTerm (V v1) (Lam i2 l2)) False)
(rule (eqTerm (V v1) (V v2)) (!EQ v1 v2))
(rule (mklam (V name) e) (Lam name e))
(rule (lamvar (Lam var exp)) (V var))
(rule (lambody (Lam var exp)) exp)
(rule (isvar (App t1 t2)) False)
(rule (isvar (Lam int term)) False)
(rule (isvar (V int)) True)
(rule (islam (App t1 t2)) False)
(rule (islam (Lam int term)) True)
(rule (islam (V int)) False)
(rule (appe2 (App e1 e2)) e2)
(rule (appe1 (App e1 e2)) e1)
(rule (mkapp e1 e2) (App e1 e2))
(rule (lambdaint e) (red e))
(rule (and False False) False :cost 0)
(rule (and True False) False :cost 0)
(rule (and False True) False :cost 0)
(rule (and True True) True :cost 0)
(rule (!EQ (S x) (S y)) (!EQ x y) :cost 0)
(rule (!EQ 0 (S y)) False :cost 0)
(rule (!EQ (S x) 0) False :cost 0)
(rule (!EQ 0 0) True :cost 0)
(rule (red[Let][Let] e (Lam var exp) a) (red (subst (V var) a exp)) :cost 0)
(rule (subst[True][Ite] False x a (Lam var exp)) (mklam (V var) (subst x a exp)) :cost 0)
(rule (red[Let][Let] e (App t1 t2) e2) (App (App t1 t2) e2) :cost 0)
(rule (red[Let][Let] e (V int) e2) (App (V int) e2) :cost 0)
(rule (red[Let] (App e1 e2) f) (red[Let][Let] (App e1 e2) f (red e2)) :cost 0)
(rule (subst[True][Ite] True x a e) e :cost 0)
(rule (subst[Ite] False x a e) e :cost 0)
(rule (subst[Ite] True x a e) a :cost 0)
