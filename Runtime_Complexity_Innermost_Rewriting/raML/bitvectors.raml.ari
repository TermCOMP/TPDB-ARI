; @origtpdbfilename tct_complexity/raML/bitvectors.raml.trs
; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/raML/bitvectors.raml.xml"
(format TRS)
(fun #natsub 2)
(fun - 2)
(fun sub 2)
(fun diff#1 1)
(fun #natdiv 2)
(fun #ckgt 1)
(fun #add 2)
(fun mult#2 3)
(fun div 2)
(fun bitToInt'#1 2)
(fun sum 3)
(fun #EQ 0)
(fun mod 2)
(fun #and 2)
(fun mult3 3)
(fun sub#1 1)
(fun #compare 2)
(fun nil 0)
(fun leq 2)
(fun #greater 2)
(fun bitToInt' 2)
(fun mult 2)
(fun bitToInt 1)
(fun sum#2 2)
(fun sum#1 1)
(fun + 2)
(fun sum#4 1)
(fun * 2)
(fun #neg 1)
(fun sub'#5 3)
(fun #less 2)
(fun sub'#3 3)
(fun #equal 2)
(fun #eq 2)
(fun #natmult 2)
(fun #divByZero 0)
(fun sub'#2 4)
(fun compare#2 3)
(fun #true 0)
(fun sub'#4 2)
(fun compare#5 3)
(fun compare#3 3)
(fun #cklt 1)
(fun add 2)
(fun #sub 2)
(fun #pos 1)
(fun add'#3 3)
(fun sub'#1 3)
(fun mult#3 3)
(fun add'#1 3)
(fun add'#2 4)
(fun tuple#2 2)
(fun diff 3)
(fun #false 0)
(fun mult#1 2)
(fun :: 2)
(fun #LT 0)
(fun #mult 2)
(fun #succ 1)
(fun sub' 3)
(fun compare 2)
(fun compare#6 1)
(fun compare#4 4)
(fun #0 0)
(fun sum#3 2)
(fun #div 2)
(fun add' 3)
(fun compare#1 2)
(fun #abs 1)
(fun #pred 1)
(fun #s 1)
(fun #GT 0)
(rule (#abs #0) #0)
(rule (#abs (#neg @x)) (#pos @x))
(rule (#abs (#pos @x)) (#pos @x))
(rule (#abs (#s @x)) (#pos (#s @x)))
(rule (#equal @x @y) (#eq @x @y))
(rule (#greater @x @y) (#ckgt (#compare @x @y)))
(rule (#less @x @y) (#cklt (#compare @x @y)))
(rule (* @x @y) (#mult @x @y))
(rule (+ @x @y) (#add @x @y))
(rule (- @x @y) (#sub @x @y))
(rule (add @b1 @b2) (add' @b1 @b2 (#abs #0)))
(rule (add' @b1 @b2 @r) (add'#1 @b1 @b2 @r))
(rule (add'#1 (:: @x @xs) @b2 @r) (add'#2 @b2 @r @x @xs))
(rule (add'#1 nil @b2 @r) nil)
(rule (add'#2 (:: @y @ys) @r @x @xs) (add'#3 (sum @x @y @r) @xs @ys))
(rule (add'#2 nil @r @x @xs) nil)
(rule (add'#3 (tuple#2 @z @r') @xs @ys) (:: @z (add' @xs @ys @r')))
(rule (bitToInt @b) (bitToInt' @b (#abs (#pos (#s #0)))))
(rule (bitToInt' @b @n) (bitToInt'#1 @b @n))
(rule (bitToInt'#1 (:: @x @xs) @n) (+ (* @x @n) (bitToInt' @xs (* @n (#pos (#s (#s #0)))))))
(rule (bitToInt'#1 nil @n) (#abs #0))
(rule (compare @b1 @b2) (compare#1 @b1 @b2))
(rule (compare#1 (:: @x @xs) @b2) (compare#2 @b2 @x @xs))
(rule (compare#1 nil @b2) (#abs #0))
(rule (compare#2 (:: @y @ys) @x @xs) (compare#3 (compare @xs @ys) @x @y))
(rule (compare#2 nil @x @xs) (#abs #0))
(rule (compare#3 @r @x @y) (compare#4 (#equal @r #0) @r @x @y))
(rule (compare#4 #false @r @x @y) @r)
(rule (compare#4 #true @r @x @y) (compare#5 (#less @x @y) @x @y))
(rule (compare#5 #false @x @y) (compare#6 (#greater @x @y)))
(rule (compare#5 #true @x @y) (- #0 (#pos (#s #0))))
(rule (compare#6 #false) (#abs #0))
(rule (compare#6 #true) (#abs (#pos (#s #0))))
(rule (diff @x @y @r) (tuple#2 (mod (+ (+ @x @y) @r) (#pos (#s (#s #0)))) (diff#1 (#less (- (- @x @y) @r) #0))))
(rule (diff#1 #false) (#abs #0))
(rule (diff#1 #true) (#abs (#pos (#s #0))))
(rule (div @x @y) (#div @x @y))
(rule (leq @b1 @b2) (#less (compare @b1 @b2) (#pos (#s #0))))
(rule (mod @x @y) (- @x (* @x (div @x @y))))
(rule (mult @b1 @b2) (mult#1 @b1 @b2))
(rule (mult#1 (:: @x @xs) @b2) (mult#2 (:: (#abs #0) (mult @xs @b2)) @b2 @x))
(rule (mult#1 nil @b2) nil)
(rule (mult#2 @zs @b2 @x) (mult#3 (#equal @x (#pos (#s #0))) @b2 @zs))
(rule (mult#3 #false @b2 @zs) @zs)
(rule (mult#3 #true @b2 @zs) (add @b2 @zs))
(rule (mult3 @b1 @b2 @b3) (mult (mult @b1 @b2) @b2))
(rule (sub @b1 @b2) (sub#1 (sub' @b1 @b2 (#abs #0))))
(rule (sub#1 (tuple#2 @b @_@1)) @b)
(rule (sub' @b1 @b2 @r) (sub'#1 @b1 @b2 @r))
(rule (sub'#1 (:: @x @xs) @b2 @r) (sub'#2 @b2 @r @x @xs))
(rule (sub'#1 nil @b2 @r) (tuple#2 nil @r))
(rule (sub'#2 (:: @y @ys) @r @x @xs) (sub'#3 (diff @x @y @r) @xs @ys))
(rule (sub'#2 nil @r @x @xs) (tuple#2 nil @r))
(rule (sub'#3 (tuple#2 @z @r') @xs @ys) (sub'#4 (sub' @xs @ys @r') @z))
(rule (sub'#4 (tuple#2 @zs @s) @z) (tuple#2 (sub'#5 (#equal @s (#pos (#s #0))) @z @zs) @s))
(rule (sub'#5 #false @z @zs) (:: @z @zs))
(rule (sub'#5 #true @z @zs) (:: (#abs #0) @zs))
(rule (sum @x @y @r) (sum#1 (+ (+ @x @y) @r)))
(rule (sum#1 @s) (sum#2 (#equal @s #0) @s))
(rule (sum#2 #false @s) (sum#3 (#equal @s (#pos (#s #0))) @s))
(rule (sum#2 #true @s) (tuple#2 (#abs #0) (#abs #0)))
(rule (sum#3 #false @s) (sum#4 (#equal @s (#pos (#s (#s #0))))))
(rule (sum#3 #true @s) (tuple#2 (#abs (#pos (#s #0))) (#abs #0)))
(rule (sum#4 #false) (tuple#2 (#abs (#pos (#s #0))) (#abs (#pos (#s #0)))))
(rule (sum#4 #true) (tuple#2 (#abs #0) (#abs (#pos (#s #0)))))
(rule (#add #0 @y) @y :cost 0)
(rule (#add (#neg (#s #0)) @y) (#pred @y) :cost 0)
(rule (#add (#neg (#s (#s @x))) @y) (#pred (#add (#pos (#s @x)) @y)) :cost 0)
(rule (#add (#pos (#s #0)) @y) (#succ @y) :cost 0)
(rule (#add (#pos (#s (#s @x))) @y) (#succ (#add (#pos (#s @x)) @y)) :cost 0)
(rule (#and #false #false) #false :cost 0)
(rule (#and #false #true) #false :cost 0)
(rule (#and #true #false) #false :cost 0)
(rule (#and #true #true) #true :cost 0)
(rule (#ckgt #EQ) #false :cost 0)
(rule (#ckgt #GT) #true :cost 0)
(rule (#ckgt #LT) #false :cost 0)
(rule (#cklt #EQ) #false :cost 0)
(rule (#cklt #GT) #false :cost 0)
(rule (#cklt #LT) #true :cost 0)
(rule (#compare #0 #0) #EQ :cost 0)
(rule (#compare #0 (#neg @y)) #GT :cost 0)
(rule (#compare #0 (#pos @y)) #LT :cost 0)
(rule (#compare #0 (#s @y)) #LT :cost 0)
(rule (#compare (#neg @x) #0) #LT :cost 0)
(rule (#compare (#neg @x) (#neg @y)) (#compare @y @x) :cost 0)
(rule (#compare (#neg @x) (#pos @y)) #LT :cost 0)
(rule (#compare (#pos @x) #0) #GT :cost 0)
(rule (#compare (#pos @x) (#neg @y)) #GT :cost 0)
(rule (#compare (#pos @x) (#pos @y)) (#compare @x @y) :cost 0)
(rule (#compare (#s @x) #0) #GT :cost 0)
(rule (#compare (#s @x) (#s @y)) (#compare @x @y) :cost 0)
(rule (#div #0 #0) #divByZero :cost 0)
(rule (#div #0 (#neg @y)) #0 :cost 0)
(rule (#div #0 (#pos @y)) #0 :cost 0)
(rule (#div (#neg @x) #0) #divByZero :cost 0)
(rule (#div (#neg @x) (#neg @y)) (#pos (#natdiv @x @y)) :cost 0)
(rule (#div (#neg @x) (#pos @y)) (#neg (#natdiv @x @y)) :cost 0)
(rule (#div (#pos @x) #0) #divByZero :cost 0)
(rule (#div (#pos @x) (#neg @y)) (#neg (#natdiv @x @y)) :cost 0)
(rule (#div (#pos @x) (#pos @y)) (#pos (#natdiv @x @y)) :cost 0)
(rule (#eq #0 #0) #true :cost 0)
(rule (#eq #0 (#neg @y)) #false :cost 0)
(rule (#eq #0 (#pos @y)) #false :cost 0)
(rule (#eq #0 (#s @y)) #false :cost 0)
(rule (#eq (#neg @x) #0) #false :cost 0)
(rule (#eq (#neg @x) (#neg @y)) (#eq @x @y) :cost 0)
(rule (#eq (#neg @x) (#pos @y)) #false :cost 0)
(rule (#eq (#pos @x) #0) #false :cost 0)
(rule (#eq (#pos @x) (#neg @y)) #false :cost 0)
(rule (#eq (#pos @x) (#pos @y)) (#eq @x @y) :cost 0)
(rule (#eq (#s @x) #0) #false :cost 0)
(rule (#eq (#s @x) (#s @y)) (#eq @x @y) :cost 0)
(rule (#eq (:: @x_1 @x_2) (:: @y_1 @y_2)) (#and (#eq @x_1 @y_1) (#eq @x_2 @y_2)) :cost 0)
(rule (#eq (:: @x_1 @x_2) nil) #false :cost 0)
(rule (#eq (:: @x_1 @x_2) (tuple#2 @y_1 @y_2)) #false :cost 0)
(rule (#eq nil (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq nil nil) #true :cost 0)
(rule (#eq nil (tuple#2 @y_1 @y_2)) #false :cost 0)
(rule (#eq (tuple#2 @x_1 @x_2) (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq (tuple#2 @x_1 @x_2) nil) #false :cost 0)
(rule (#eq (tuple#2 @x_1 @x_2) (tuple#2 @y_1 @y_2)) (#and (#eq @x_1 @y_1) (#eq @x_2 @y_2)) :cost 0)
(rule (#mult #0 #0) #0 :cost 0)
(rule (#mult #0 (#neg @y)) #0 :cost 0)
(rule (#mult #0 (#pos @y)) #0 :cost 0)
(rule (#mult (#neg @x) #0) #0 :cost 0)
(rule (#mult (#neg @x) (#neg @y)) (#pos (#natmult @x @y)) :cost 0)
(rule (#mult (#neg @x) (#pos @y)) (#neg (#natmult @x @y)) :cost 0)
(rule (#mult (#pos @x) #0) #0 :cost 0)
(rule (#mult (#pos @x) (#neg @y)) (#neg (#natmult @x @y)) :cost 0)
(rule (#mult (#pos @x) (#pos @y)) (#pos (#natmult @x @y)) :cost 0)
(rule (#natdiv #0 #0) #divByZero :cost 0)
(rule (#natdiv (#s @x) (#s @y)) (#s (#natdiv (#natsub @x @y) (#s @y))) :cost 0)
(rule (#natmult #0 @y) #0 :cost 0)
(rule (#natmult (#s @x) @y) (#add (#pos @y) (#natmult @x @y)) :cost 0)
(rule (#natsub @x #0) @x :cost 0)
(rule (#natsub (#s @x) (#s @y)) (#natsub @x @y) :cost 0)
(rule (#pred #0) (#neg (#s #0)) :cost 0)
(rule (#pred (#neg (#s @x))) (#neg (#s (#s @x))) :cost 0)
(rule (#pred (#pos (#s #0))) #0 :cost 0)
(rule (#pred (#pos (#s (#s @x)))) (#pos (#s @x)) :cost 0)
(rule (#sub @x #0) @x :cost 0)
(rule (#sub @x (#neg @y)) (#add @x (#pos @y)) :cost 0)
(rule (#sub @x (#pos @y)) (#add @x (#neg @y)) :cost 0)
(rule (#succ #0) (#pos (#s #0)) :cost 0)
(rule (#succ (#neg (#s #0))) #0 :cost 0)
(rule (#succ (#neg (#s (#s @x)))) (#neg (#s @x)) :cost 0)
(rule (#succ (#pos (#s @x))) (#pos (#s (#s @x))) :cost 0)
