; @origtpdbfilename tct_complexity/raML/bfs.raml.trs
; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/raML/bfs.raml.xml"
(format TRS)
(fun #equal 2)
(fun bfs#4 7)
(fun #eq 2)
(fun reverse 1)
(fun appendreverse#1 2)
(fun appendreverse 2)
(fun #true 0)
(fun leaf 0)
(fun dfs#1 2)
(fun dobfs 2)
(fun #pos 1)
(fun dodfs 2)
(fun bfs2#1 2)
(fun node 3)
(fun bfs2 2)
(fun bfs 3)
(fun #and 2)
(fun nil 0)
(fun bfs#2 2)
(fun #false 0)
(fun :: 2)
(fun bfs#1 3)
(fun dfs#2 4)
(fun bfs#3 4)
(fun #0 0)
(fun dfs 2)
(fun #neg 1)
(fun #s 1)
(fun dfs#3 6)
(rule (#equal @x @y) (#eq @x @y))
(rule (appendreverse @toreverse @sofar) (appendreverse#1 @toreverse @sofar))
(rule (appendreverse#1 (:: @a @as) @sofar) (appendreverse @as (:: @a @sofar)))
(rule (appendreverse#1 nil @sofar) @sofar)
(rule (bfs @queue @futurequeue @x) (bfs#1 @queue @futurequeue @x))
(rule (bfs#1 (:: @t @ts) @futurequeue @x) (bfs#3 @t @futurequeue @ts @x))
(rule (bfs#1 nil @futurequeue @x) (bfs#2 @futurequeue @x))
(rule (bfs#2 (:: @t @ts) @x) (bfs (reverse (:: @t @ts)) nil @x))
(rule (bfs#2 nil @x) leaf)
(rule (bfs#3 leaf @futurequeue @ts @x) (bfs @ts @futurequeue @x))
(rule (bfs#3 (node @y @t1 @t2) @futurequeue @ts @x) (bfs#4 (#equal @x @y) @futurequeue @t1 @t2 @ts @x @y))
(rule (bfs#4 #false @futurequeue @t1 @t2 @ts @x @y) (bfs @ts (:: @t2 (:: @t1 @futurequeue)) @x))
(rule (bfs#4 #true @futurequeue @t1 @t2 @ts @x @y) (node @y @t1 @t2))
(rule (bfs2 @t @x) (bfs2#1 (dobfs @t @x) @x))
(rule (bfs2#1 @t' @x) (dobfs @t' @x))
(rule (dfs @queue @x) (dfs#1 @queue @x))
(rule (dfs#1 (:: @t @ts) @x) (dfs#2 @t @t @ts @x))
(rule (dfs#1 nil @x) leaf)
(rule (dfs#2 leaf @t @ts @x) (dfs @ts @x))
(rule (dfs#2 (node @a @t1 @t2) @t @ts @x) (dfs#3 (#equal @a @x) @t @t1 @t2 @ts @x))
(rule (dfs#3 #false @t @t1 @t2 @ts @x) (dfs (:: @t1 (:: @t2 @ts)) @x))
(rule (dfs#3 #true @t @t1 @t2 @ts @x) @t)
(rule (dobfs @t @x) (bfs (:: @t nil) nil @x))
(rule (dodfs @t @x) (dfs (:: @t nil) @x))
(rule (reverse @xs) (appendreverse @xs nil))
(rule (#and #false #false) #false :cost 0)
(rule (#and #false #true) #false :cost 0)
(rule (#and #true #false) #false :cost 0)
(rule (#and #true #true) #true :cost 0)
(rule (#eq #0 #0) #true :cost 0)
(rule (#eq #0 (#neg @y)) #false :cost 0)
(rule (#eq #0 (#pos @y)) #false :cost 0)
(rule (#eq #0 (#s @y)) #false :cost 0)
(rule (#eq (#neg @x) #0) #false :cost 0)
(rule (#eq (#neg @x) (#neg @y)) (#eq @x @y) :cost 0)
(rule (#eq (#neg @x) (#pos @y)) #false :cost 0)
(rule (#eq (#pos @x) #0) #false :cost 0)
(rule (#eq (#pos @x) (#neg @y)) #false :cost 0)
(rule (#eq (#pos @x) (#pos @y)) (#eq @x @y) :cost 0)
(rule (#eq (#s @x) #0) #false :cost 0)
(rule (#eq (#s @x) (#s @y)) (#eq @x @y) :cost 0)
(rule (#eq (:: @x_1 @x_2) (:: @y_1 @y_2)) (#and (#eq @x_1 @y_1) (#eq @x_2 @y_2)) :cost 0)
(rule (#eq (:: @x_1 @x_2) leaf) #false :cost 0)
(rule (#eq (:: @x_1 @x_2) nil) #false :cost 0)
(rule (#eq (:: @x_1 @x_2) (node @y_1 @y_2 @y_3)) #false :cost 0)
(rule (#eq leaf (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq leaf leaf) #true :cost 0)
(rule (#eq leaf nil) #false :cost 0)
(rule (#eq leaf (node @y_1 @y_2 @y_3)) #false :cost 0)
(rule (#eq nil (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq nil leaf) #false :cost 0)
(rule (#eq nil nil) #true :cost 0)
(rule (#eq nil (node @y_1 @y_2 @y_3)) #false :cost 0)
(rule (#eq (node @x_1 @x_2 @x_3) (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq (node @x_1 @x_2 @x_3) leaf) #false :cost 0)
(rule (#eq (node @x_1 @x_2 @x_3) nil) #false :cost 0)
(rule (#eq (node @x_1 @x_2 @x_3) (node @y_1 @y_2 @y_3)) (#and (#eq @x_1 @y_1) (#and (#eq @x_2 @y_2) (#eq @x_3 @y_3))) :cost 0)
