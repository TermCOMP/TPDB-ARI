; @origtpdbfilename tct_complexity/raML/longestCommonSubsequence.raml.trs
; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/raML/longestCommonSubsequence.raml.xml"
(format TRS)
(fun firstline#1 1)
(fun #equal 2)
(fun #eq 2)
(fun lcs#3 1)
(fun lcs#1 1)
(fun lcstable 2)
(fun lcstable#3 3)
(fun newline#7 4)
(fun #true 0)
(fun lcs#2 1)
(fun lcs 2)
(fun newline#5 6)
(fun right#1 1)
(fun newline#2 4)
(fun firstline 1)
(fun #ckgt 1)
(fun #add 2)
(fun #pos 1)
(fun #EQ 0)
(fun #and 2)
(fun #compare 2)
(fun lcstable#1 2)
(fun nil 0)
(fun #greater 2)
(fun newline 3)
(fun newline#4 6)
(fun max 2)
(fun right 1)
(fun #false 0)
(fun :: 2)
(fun #LT 0)
(fun max#1 3)
(fun + 2)
(fun #succ 1)
(fun newline#3 5)
(fun #0 0)
(fun #neg 1)
(fun #abs 1)
(fun lcstable#2 3)
(fun #pred 1)
(fun newline#6 2)
(fun newline#1 3)
(fun #s 1)
(fun #GT 0)
(rule (#abs #0) #0)
(rule (#abs (#neg @x)) (#pos @x))
(rule (#abs (#pos @x)) (#pos @x))
(rule (#abs (#s @x)) (#pos (#s @x)))
(rule (#equal @x @y) (#eq @x @y))
(rule (#greater @x @y) (#ckgt (#compare @x @y)))
(rule (+ @x @y) (#add @x @y))
(rule (firstline @l) (firstline#1 @l))
(rule (firstline#1 (:: @x @xs)) (:: (#abs #0) (firstline @xs)))
(rule (firstline#1 nil) nil)
(rule (lcs @l1 @l2) (lcs#1 (lcstable @l1 @l2)))
(rule (lcs#1 @m) (lcs#2 @m))
(rule (lcs#2 (:: @l1 @_@2)) (lcs#3 @l1))
(rule (lcs#2 nil) (#abs #0))
(rule (lcs#3 (:: @len @_@1)) @len)
(rule (lcs#3 nil) (#abs #0))
(rule (lcstable @l1 @l2) (lcstable#1 @l1 @l2))
(rule (lcstable#1 (:: @x @xs) @l2) (lcstable#2 (lcstable @xs @l2) @l2 @x))
(rule (lcstable#1 nil @l2) (:: (firstline @l2) nil))
(rule (lcstable#2 @m @l2 @x) (lcstable#3 @m @l2 @x))
(rule (lcstable#3 (:: @l @ls) @l2 @x) (:: (newline @x @l @l2) (:: @l @ls)))
(rule (lcstable#3 nil @l2 @x) nil)
(rule (max @a @b) (max#1 (#greater @a @b) @a @b))
(rule (max#1 #false @a @b) @b)
(rule (max#1 #true @a @b) @a)
(rule (newline @y @lastline @l) (newline#1 @l @lastline @y))
(rule (newline#1 (:: @x @xs) @lastline @y) (newline#2 @lastline @x @xs @y))
(rule (newline#1 nil @lastline @y) nil)
(rule (newline#2 (:: @belowVal @lastline') @x @xs @y) (newline#3 (newline @y @lastline' @xs) @belowVal @lastline' @x @y))
(rule (newline#2 nil @x @xs @y) nil)
(rule (newline#3 @nl @belowVal @lastline' @x @y) (newline#4 (right @nl) @belowVal @lastline' @nl @x @y))
(rule (newline#4 @rightVal @belowVal @lastline' @nl @x @y) (newline#5 (right @lastline') @belowVal @nl @rightVal @x @y))
(rule (newline#5 @diagVal @belowVal @nl @rightVal @x @y) (newline#6 (newline#7 (#equal @x @y) @belowVal @diagVal @rightVal) @nl))
(rule (newline#6 @elem @nl) (:: @elem @nl))
(rule (newline#7 #false @belowVal @diagVal @rightVal) (max @belowVal @rightVal))
(rule (newline#7 #true @belowVal @diagVal @rightVal) (+ @diagVal (#pos (#s #0))))
(rule (right @l) (right#1 @l))
(rule (right#1 (:: @x @xs)) @x)
(rule (right#1 nil) (#abs #0))
(rule (#add #0 @y) @y :cost 0)
(rule (#add (#neg (#s #0)) @y) (#pred @y) :cost 0)
(rule (#add (#neg (#s (#s @x))) @y) (#pred (#add (#pos (#s @x)) @y)) :cost 0)
(rule (#add (#pos (#s #0)) @y) (#succ @y) :cost 0)
(rule (#add (#pos (#s (#s @x))) @y) (#succ (#add (#pos (#s @x)) @y)) :cost 0)
(rule (#and #false #false) #false :cost 0)
(rule (#and #false #true) #false :cost 0)
(rule (#and #true #false) #false :cost 0)
(rule (#and #true #true) #true :cost 0)
(rule (#ckgt #EQ) #false :cost 0)
(rule (#ckgt #GT) #true :cost 0)
(rule (#ckgt #LT) #false :cost 0)
(rule (#compare #0 #0) #EQ :cost 0)
(rule (#compare #0 (#neg @y)) #GT :cost 0)
(rule (#compare #0 (#pos @y)) #LT :cost 0)
(rule (#compare #0 (#s @y)) #LT :cost 0)
(rule (#compare (#neg @x) #0) #LT :cost 0)
(rule (#compare (#neg @x) (#neg @y)) (#compare @y @x) :cost 0)
(rule (#compare (#neg @x) (#pos @y)) #LT :cost 0)
(rule (#compare (#pos @x) #0) #GT :cost 0)
(rule (#compare (#pos @x) (#neg @y)) #GT :cost 0)
(rule (#compare (#pos @x) (#pos @y)) (#compare @x @y) :cost 0)
(rule (#compare (#s @x) #0) #GT :cost 0)
(rule (#compare (#s @x) (#s @y)) (#compare @x @y) :cost 0)
(rule (#eq #0 #0) #true :cost 0)
(rule (#eq #0 (#neg @y)) #false :cost 0)
(rule (#eq #0 (#pos @y)) #false :cost 0)
(rule (#eq #0 (#s @y)) #false :cost 0)
(rule (#eq (#neg @x) #0) #false :cost 0)
(rule (#eq (#neg @x) (#neg @y)) (#eq @x @y) :cost 0)
(rule (#eq (#neg @x) (#pos @y)) #false :cost 0)
(rule (#eq (#pos @x) #0) #false :cost 0)
(rule (#eq (#pos @x) (#neg @y)) #false :cost 0)
(rule (#eq (#pos @x) (#pos @y)) (#eq @x @y) :cost 0)
(rule (#eq (#s @x) #0) #false :cost 0)
(rule (#eq (#s @x) (#s @y)) (#eq @x @y) :cost 0)
(rule (#eq (:: @x_1 @x_2) (:: @y_1 @y_2)) (#and (#eq @x_1 @y_1) (#eq @x_2 @y_2)) :cost 0)
(rule (#eq (:: @x_1 @x_2) nil) #false :cost 0)
(rule (#eq nil (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq nil nil) #true :cost 0)
(rule (#pred #0) (#neg (#s #0)) :cost 0)
(rule (#pred (#neg (#s @x))) (#neg (#s (#s @x))) :cost 0)
(rule (#pred (#pos (#s #0))) #0 :cost 0)
(rule (#pred (#pos (#s (#s @x)))) (#pos (#s @x)) :cost 0)
(rule (#succ #0) (#pos (#s #0)) :cost 0)
(rule (#succ (#neg (#s #0))) #0 :cost 0)
(rule (#succ (#neg (#s (#s @x)))) (#neg (#s @x)) :cost 0)
(rule (#succ (#pos (#s @x))) (#pos (#s (#s @x))) :cost 0)
