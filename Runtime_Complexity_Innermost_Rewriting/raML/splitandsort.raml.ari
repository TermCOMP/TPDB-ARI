; @origtpdbfilename tct_complexity/raML/splitandsort.raml.trs
; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/raML/splitandsort.raml.xml"
(format TRS)
(fun #equal 2)
(fun #eq 2)
(fun splitAndSort 1)
(fun sortAll#2 2)
(fun quicksort#2 2)
(fun split 1)
(fun #true 0)
(fun append 2)
(fun insert#3 5)
(fun #ckgt 1)
(fun insert 2)
(fun #pos 1)
(fun sortAll 1)
(fun #EQ 0)
(fun insert#2 4)
(fun #and 2)
(fun sortAll#1 1)
(fun #compare 2)
(fun tuple#2 2)
(fun nil 0)
(fun split#1 1)
(fun #greater 2)
(fun insert#4 6)
(fun insert#1 3)
(fun quicksort#1 1)
(fun append#1 2)
(fun splitqs 2)
(fun #false 0)
(fun quicksort 1)
(fun :: 2)
(fun #LT 0)
(fun splitqs#3 4)
(fun splitqs#2 3)
(fun #0 0)
(fun #neg 1)
(fun #s 1)
(fun #GT 0)
(fun splitqs#1 2)
(rule (#equal @x @y) (#eq @x @y))
(rule (#greater @x @y) (#ckgt (#compare @x @y)))
(rule (append @l @ys) (append#1 @l @ys))
(rule (append#1 (:: @x @xs) @ys) (:: @x (append @xs @ys)))
(rule (append#1 nil @ys) @ys)
(rule (insert @x @l) (insert#1 @x @l @x))
(rule (insert#1 (tuple#2 @valX @keyX) @l @x) (insert#2 @l @keyX @valX @x))
(rule (insert#2 (:: @l1 @ls) @keyX @valX @x) (insert#3 @l1 @keyX @ls @valX @x))
(rule (insert#2 nil @keyX @valX @x) (:: (tuple#2 (:: @valX nil) @keyX) nil))
(rule (insert#3 (tuple#2 @vals1 @key1) @keyX @ls @valX @x) (insert#4 (#equal @key1 @keyX) @key1 @ls @valX @vals1 @x))
(rule (insert#4 #false @key1 @ls @valX @vals1 @x) (:: (tuple#2 @vals1 @key1) (insert @x @ls)))
(rule (insert#4 #true @key1 @ls @valX @vals1 @x) (:: (tuple#2 (:: @valX @vals1) @key1) @ls))
(rule (quicksort @l) (quicksort#1 @l))
(rule (quicksort#1 (:: @z @zs)) (quicksort#2 (splitqs @z @zs) @z))
(rule (quicksort#1 nil) nil)
(rule (quicksort#2 (tuple#2 @xs @ys) @z) (append (quicksort @xs) (:: @z (quicksort @ys))))
(rule (sortAll @l) (sortAll#1 @l))
(rule (sortAll#1 (:: @x @xs)) (sortAll#2 @x @xs))
(rule (sortAll#1 nil) nil)
(rule (sortAll#2 (tuple#2 @vals @key) @xs) (:: (tuple#2 (quicksort @vals) @key) (sortAll @xs)))
(rule (split @l) (split#1 @l))
(rule (split#1 (:: @x @xs)) (insert @x (split @xs)))
(rule (split#1 nil) nil)
(rule (splitAndSort @l) (sortAll (split @l)))
(rule (splitqs @pivot @l) (splitqs#1 @l @pivot))
(rule (splitqs#1 (:: @x @xs) @pivot) (splitqs#2 (splitqs @pivot @xs) @pivot @x))
(rule (splitqs#1 nil @pivot) (tuple#2 nil nil))
(rule (splitqs#2 (tuple#2 @ls @rs) @pivot @x) (splitqs#3 (#greater @x @pivot) @ls @rs @x))
(rule (splitqs#3 #false @ls @rs @x) (tuple#2 (:: @x @ls) @rs))
(rule (splitqs#3 #true @ls @rs @x) (tuple#2 @ls (:: @x @rs)))
(rule (#and #false #false) #false :cost 0)
(rule (#and #false #true) #false :cost 0)
(rule (#and #true #false) #false :cost 0)
(rule (#and #true #true) #true :cost 0)
(rule (#ckgt #EQ) #false :cost 0)
(rule (#ckgt #GT) #true :cost 0)
(rule (#ckgt #LT) #false :cost 0)
(rule (#compare #0 #0) #EQ :cost 0)
(rule (#compare #0 (#neg @y)) #GT :cost 0)
(rule (#compare #0 (#pos @y)) #LT :cost 0)
(rule (#compare #0 (#s @y)) #LT :cost 0)
(rule (#compare (#neg @x) #0) #LT :cost 0)
(rule (#compare (#neg @x) (#neg @y)) (#compare @y @x) :cost 0)
(rule (#compare (#neg @x) (#pos @y)) #LT :cost 0)
(rule (#compare (#pos @x) #0) #GT :cost 0)
(rule (#compare (#pos @x) (#neg @y)) #GT :cost 0)
(rule (#compare (#pos @x) (#pos @y)) (#compare @x @y) :cost 0)
(rule (#compare (#s @x) #0) #GT :cost 0)
(rule (#compare (#s @x) (#s @y)) (#compare @x @y) :cost 0)
(rule (#eq #0 #0) #true :cost 0)
(rule (#eq #0 (#neg @y)) #false :cost 0)
(rule (#eq #0 (#pos @y)) #false :cost 0)
(rule (#eq #0 (#s @y)) #false :cost 0)
(rule (#eq (#neg @x) #0) #false :cost 0)
(rule (#eq (#neg @x) (#neg @y)) (#eq @x @y) :cost 0)
(rule (#eq (#neg @x) (#pos @y)) #false :cost 0)
(rule (#eq (#pos @x) #0) #false :cost 0)
(rule (#eq (#pos @x) (#neg @y)) #false :cost 0)
(rule (#eq (#pos @x) (#pos @y)) (#eq @x @y) :cost 0)
(rule (#eq (#s @x) #0) #false :cost 0)
(rule (#eq (#s @x) (#s @y)) (#eq @x @y) :cost 0)
(rule (#eq (:: @x_1 @x_2) (:: @y_1 @y_2)) (#and (#eq @x_1 @y_1) (#eq @x_2 @y_2)) :cost 0)
(rule (#eq (:: @x_1 @x_2) nil) #false :cost 0)
(rule (#eq (:: @x_1 @x_2) (tuple#2 @y_1 @y_2)) #false :cost 0)
(rule (#eq nil (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq nil nil) #true :cost 0)
(rule (#eq nil (tuple#2 @y_1 @y_2)) #false :cost 0)
(rule (#eq (tuple#2 @x_1 @x_2) (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq (tuple#2 @x_1 @x_2) nil) #false :cost 0)
(rule (#eq (tuple#2 @x_1 @x_2) (tuple#2 @y_1 @y_2)) (#and (#eq @x_1 @y_1) (#eq @x_2 @y_2)) :cost 0)
