; @origtpdbfilename tct_complexity/raML/listsort.raml.trs
; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/raML/listsort.raml.xml"
(format TRS)
(fun #equal 2)
(fun #eq 2)
(fun leq#2 3)
(fun or 2)
(fun #true 0)
(fun and 2)
(fun isortlist 1)
(fun leq#1 2)
(fun #cklt 1)
(fun insert 2)
(fun #pos 1)
(fun #EQ 0)
(fun insert#2 4)
(fun #and 2)
(fun #compare 2)
(fun nil 0)
(fun leq 2)
(fun #false 0)
(fun :: 2)
(fun isortlist#1 1)
(fun #LT 0)
(fun #or 2)
(fun insert#1 2)
(fun #0 0)
(fun #neg 1)
(fun #less 2)
(fun #s 1)
(fun #GT 0)
(rule (#equal @x @y) (#eq @x @y))
(rule (#less @x @y) (#cklt (#compare @x @y)))
(rule (and @x @y) (#and @x @y))
(rule (insert @x @l) (insert#1 @l @x))
(rule (insert#1 (:: @y @ys) @x) (insert#2 (leq @x @y) @x @y @ys))
(rule (insert#1 nil @x) (:: @x nil))
(rule (insert#2 #false @x @y @ys) (:: @y (insert @x @ys)))
(rule (insert#2 #true @x @y @ys) (:: @x (:: @y @ys)))
(rule (isortlist @l) (isortlist#1 @l))
(rule (isortlist#1 (:: @x @xs)) (insert @x (isortlist @xs)))
(rule (isortlist#1 nil) nil)
(rule (leq @l1 @l2) (leq#1 @l1 @l2))
(rule (leq#1 (:: @x @xs) @l2) (leq#2 @l2 @x @xs))
(rule (leq#1 nil @l2) #true)
(rule (leq#2 (:: @y @ys) @x @xs) (or (#less @x @y) (and (#equal @x @y) (leq @xs @ys))))
(rule (leq#2 nil @x @xs) #false)
(rule (or @x @y) (#or @x @y))
(rule (#and #false #false) #false :cost 0)
(rule (#and #false #true) #false :cost 0)
(rule (#and #true #false) #false :cost 0)
(rule (#and #true #true) #true :cost 0)
(rule (#cklt #EQ) #false :cost 0)
(rule (#cklt #GT) #false :cost 0)
(rule (#cklt #LT) #true :cost 0)
(rule (#compare #0 #0) #EQ :cost 0)
(rule (#compare #0 (#neg @y)) #GT :cost 0)
(rule (#compare #0 (#pos @y)) #LT :cost 0)
(rule (#compare #0 (#s @y)) #LT :cost 0)
(rule (#compare (#neg @x) #0) #LT :cost 0)
(rule (#compare (#neg @x) (#neg @y)) (#compare @y @x) :cost 0)
(rule (#compare (#neg @x) (#pos @y)) #LT :cost 0)
(rule (#compare (#pos @x) #0) #GT :cost 0)
(rule (#compare (#pos @x) (#neg @y)) #GT :cost 0)
(rule (#compare (#pos @x) (#pos @y)) (#compare @x @y) :cost 0)
(rule (#compare (#s @x) #0) #GT :cost 0)
(rule (#compare (#s @x) (#s @y)) (#compare @x @y) :cost 0)
(rule (#eq #0 #0) #true :cost 0)
(rule (#eq #0 (#neg @y)) #false :cost 0)
(rule (#eq #0 (#pos @y)) #false :cost 0)
(rule (#eq #0 (#s @y)) #false :cost 0)
(rule (#eq (#neg @x) #0) #false :cost 0)
(rule (#eq (#neg @x) (#neg @y)) (#eq @x @y) :cost 0)
(rule (#eq (#neg @x) (#pos @y)) #false :cost 0)
(rule (#eq (#pos @x) #0) #false :cost 0)
(rule (#eq (#pos @x) (#neg @y)) #false :cost 0)
(rule (#eq (#pos @x) (#pos @y)) (#eq @x @y) :cost 0)
(rule (#eq (#s @x) #0) #false :cost 0)
(rule (#eq (#s @x) (#s @y)) (#eq @x @y) :cost 0)
(rule (#eq (:: @x_1 @x_2) (:: @y_1 @y_2)) (#and (#eq @x_1 @y_1) (#eq @x_2 @y_2)) :cost 0)
(rule (#eq (:: @x_1 @x_2) nil) #false :cost 0)
(rule (#eq nil (:: @y_1 @y_2)) #false :cost 0)
(rule (#eq nil nil) #true :cost 0)
(rule (#or #false #false) #false :cost 0)
(rule (#or #false #true) #true :cost 0)
(rule (#or #true #false) #true :cost 0)
(rule (#or #true #true) #true :cost 0)
