; @origtpdbfilename tct_complexity/raML/bft_mmult.raml.trs
; @xtcfilename "./Runtime_Complexity_Innermost_Rewriting/raML/bft_mmult.raml.xml"
(format TRS)
(fun |bftMult'#2| 1)
(fun |#natmult| 2)
(fun reverse 1)
(fun |bftMult'#5| 3)
(fun |appendreverse#1| 2)
(fun |computeLine#1| 3)
(fun |bftMult'#3| 3)
(fun appendreverse 2)
(fun |matrixMult#1| 2)
(fun leaf 0)
(fun bftMult 2)
(fun lineMult 3)
(fun |lineMult#2| 4)
(fun |#pos| 1)
(fun |#add| 2)
(fun node 3)
(fun dequeue 2)
(fun |bftMult'#1| 2)
(fun |tuple#2| 2)
(fun nil 0)
(fun |bftMult'| 2)
(fun computeLine 3)
(fun |bftMult'#4| 3)
(fun |dequeue#1| 2)
(fun |::| 2)
(fun |#mult| 2)
(fun + 2)
(fun |#succ| 1)
(fun |#0| 0)
(fun |enqueue#1| 2)
(fun |#neg| 1)
(fun matrixMult 2)
(fun * 2)
(fun enqueue 2)
(fun |dequeue#2| 1)
(fun |#pred| 1)
(fun |lineMult#1| 3)
(fun |#s| 1)
(fun |computeLine#2| 4)
(rule (* @x @y) (|#mult| @x @y))
(rule (+ @x @y) (|#add| @x @y))
(rule (appendreverse @toreverse @sofar) (|appendreverse#1| @toreverse @sofar))
(rule (|appendreverse#1| (|::| @a @as) @sofar) (appendreverse @as (|::| @a @sofar)))
(rule (|appendreverse#1| nil @sofar) @sofar)
(rule (bftMult @t @acc) (|bftMult'| (|tuple#2| (|::| @t nil) nil) @acc))
(rule (|bftMult'| @queue @acc) (|bftMult'#1| (|bftMult'#2| @queue) @acc))
(rule (|bftMult'#1| (|tuple#2| @elem @queue) @acc) (|bftMult'#3| @elem @acc @queue))
(rule (|bftMult'#2| (|tuple#2| @dequeue@1 @dequeue@2)) (dequeue @dequeue@1 @dequeue@2))
(rule (|bftMult'#3| (|::| @t @_@3) @acc @queue) (|bftMult'#4| @t @acc @queue))
(rule (|bftMult'#3| nil @acc @queue) @acc)
(rule (|bftMult'#4| leaf @acc @queue) (|bftMult'| @queue @acc))
(rule (|bftMult'#4| (node @y @t1 @t2) @acc @queue) (|bftMult'#5| (enqueue @t2 (enqueue @t1 @queue)) @acc @y))
(rule (|bftMult'#5| |@queue'| @acc @y) (|bftMult'| |@queue'| (matrixMult @acc @y)))
(rule (computeLine @line @m @acc) (|computeLine#1| @line @acc @m))
(rule (|computeLine#1| (|::| @x @xs) @acc @m) (|computeLine#2| @m @acc @x @xs))
(rule (|computeLine#1| nil @acc @m) @acc)
(rule (|computeLine#2| (|::| @l @ls) @acc @x @xs) (computeLine @xs @ls (lineMult @x @l @acc)))
(rule (|computeLine#2| nil @acc @x @xs) nil)
(rule (dequeue @outq @inq) (|dequeue#1| @outq @inq))
(rule (|dequeue#1| (|::| @t @ts) @inq) (|tuple#2| (|::| @t nil) (|tuple#2| @ts @inq)))
(rule (|dequeue#1| nil @inq) (|dequeue#2| (reverse @inq)))
(rule (|dequeue#2| (|::| @t @ts)) (|tuple#2| (|::| @t nil) (|tuple#2| @ts nil)))
(rule (|dequeue#2| nil) (|tuple#2| nil (|tuple#2| nil nil)))
(rule (enqueue @t @queue) (|enqueue#1| @queue @t))
(rule (|enqueue#1| (|tuple#2| @outq @inq) @t) (|tuple#2| @outq (|::| @t @inq)))
(rule (lineMult @n @l1 @l2) (|lineMult#1| @l1 @l2 @n))
(rule (|lineMult#1| (|::| @x @xs) @l2 @n) (|lineMult#2| @l2 @n @x @xs))
(rule (|lineMult#1| nil @l2 @n) nil)
(rule (|lineMult#2| (|::| @y @ys) @n @x @xs) (|::| (+ (* @x @n) @y) (lineMult @n @xs @ys)))
(rule (|lineMult#2| nil @n @x @xs) (|::| (* @x @n) (lineMult @n @xs nil)))
(rule (matrixMult @m1 @m2) (|matrixMult#1| @m1 @m2))
(rule (|matrixMult#1| (|::| @l @ls) @m2) (|::| (computeLine @l @m2 nil) (matrixMult @ls @m2)))
(rule (|matrixMult#1| nil @m2) nil)
(rule (reverse @xs) (appendreverse @xs nil))
(rule (|#add| |#0| @y) @y :cost 0)
(rule (|#add| (|#neg| (|#s| |#0|)) @y) (|#pred| @y) :cost 0)
(rule (|#add| (|#neg| (|#s| (|#s| @x))) @y) (|#pred| (|#add| (|#pos| (|#s| @x)) @y)) :cost 0)
(rule (|#add| (|#pos| (|#s| |#0|)) @y) (|#succ| @y) :cost 0)
(rule (|#add| (|#pos| (|#s| (|#s| @x))) @y) (|#succ| (|#add| (|#pos| (|#s| @x)) @y)) :cost 0)
(rule (|#mult| |#0| |#0|) |#0| :cost 0)
(rule (|#mult| |#0| (|#neg| @y)) |#0| :cost 0)
(rule (|#mult| |#0| (|#pos| @y)) |#0| :cost 0)
(rule (|#mult| (|#neg| @x) |#0|) |#0| :cost 0)
(rule (|#mult| (|#neg| @x) (|#neg| @y)) (|#pos| (|#natmult| @x @y)) :cost 0)
(rule (|#mult| (|#neg| @x) (|#pos| @y)) (|#neg| (|#natmult| @x @y)) :cost 0)
(rule (|#mult| (|#pos| @x) |#0|) |#0| :cost 0)
(rule (|#mult| (|#pos| @x) (|#neg| @y)) (|#neg| (|#natmult| @x @y)) :cost 0)
(rule (|#mult| (|#pos| @x) (|#pos| @y)) (|#pos| (|#natmult| @x @y)) :cost 0)
(rule (|#natmult| |#0| @y) |#0| :cost 0)
(rule (|#natmult| (|#s| @x) @y) (|#add| (|#pos| @y) (|#natmult| @x @y)) :cost 0)
(rule (|#pred| |#0|) (|#neg| (|#s| |#0|)) :cost 0)
(rule (|#pred| (|#neg| (|#s| @x))) (|#neg| (|#s| (|#s| @x))) :cost 0)
(rule (|#pred| (|#pos| (|#s| |#0|))) |#0| :cost 0)
(rule (|#pred| (|#pos| (|#s| (|#s| @x)))) (|#pos| (|#s| @x)) :cost 0)
(rule (|#succ| |#0|) (|#pos| (|#s| |#0|)) :cost 0)
(rule (|#succ| (|#neg| (|#s| |#0|))) |#0| :cost 0)
(rule (|#succ| (|#neg| (|#s| (|#s| @x)))) (|#neg| (|#s| @x)) :cost 0)
(rule (|#succ| (|#pos| (|#s| @x))) (|#pos| (|#s| (|#s| @x))) :cost 0)
