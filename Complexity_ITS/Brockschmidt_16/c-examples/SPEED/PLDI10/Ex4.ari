(format LCTRS)
(theory Ints)
(fun evalEx4bb1in (-> Int Int Int Int Int))
(fun evalEx4bb2in (-> Int Int Int Int Int))
(fun evalEx4bb3in (-> Int Int Int Int Int))
(fun evalEx4bb4in (-> Int Int Int Int Int))
(fun evalEx4entryin (-> Int Int Int Int Int))
(fun evalEx4returnin (-> Int Int Int Int Int))
(fun evalEx4start (-> Int Int Int Int Int))
(fun evalEx4stop (-> Int Int Int Int Int))
(entrypoint evalEx4start)
(rule (evalEx4start A B C D) (evalEx4entryin A B C D))
(rule (evalEx4entryin A B C D) (evalEx4bb4in 1 A C D))
(rule (evalEx4bb4in A B C D) (evalEx4bb2in A B 0 B) :guard (= A 1))
(rule (evalEx4bb4in A B C D) (evalEx4returnin A B C D) :guard (>= 0 A))
(rule (evalEx4bb4in A B C D) (evalEx4returnin A B C D) :guard (>= A 2))
(rule (evalEx4bb2in A B C D) (evalEx4bb4in C D C D) :guard (>= 0 D))
(rule (evalEx4bb2in A B C D) (evalEx4bb3in A B C D) :guard (>= D 1))
(rule (evalEx4bb3in A B C D) (evalEx4bb1in A B C D) :guard (>= 0 (+ E 1)))
(rule (evalEx4bb3in A B C D) (evalEx4bb1in A B C D) :guard (>= E 1))
(rule (evalEx4bb3in A B C D) (evalEx4bb4in C D C D))
(rule (evalEx4bb1in A B C D) (evalEx4bb2in A B 1 (- D 1)))
(rule (evalEx4returnin A B C D) (evalEx4stop A B C D))
