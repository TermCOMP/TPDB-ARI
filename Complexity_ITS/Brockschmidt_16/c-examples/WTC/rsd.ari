(format LCTRS)
(theory Ints)
(fun evalrsdbb1in (-> Int Int Int Int))
(fun evalrsdbb2in (-> Int Int Int Int))
(fun evalrsdbb3in (-> Int Int Int Int))
(fun evalrsdbb4in (-> Int Int Int Int))
(fun evalrsdbbin (-> Int Int Int Int))
(fun evalrsdentryin (-> Int Int Int Int))
(fun evalrsdreturnin (-> Int Int Int Int))
(fun evalrsdstart (-> Int Int Int Int))
(fun evalrsdstop (-> Int Int Int Int))
(entrypoint evalrsdstart)
(rule (evalrsdstart A B C) (evalrsdentryin A B C))
(rule (evalrsdentryin A B C) (evalrsdbbin A B C) :guard (>= A 0))
(rule (evalrsdentryin A B C) (evalrsdreturnin A B C) :guard (>= 0 (+ A 1)))
(rule (evalrsdbbin A B C) (evalrsdbb4in A (* 2 A) (* 2 A)))
(rule (evalrsdbb4in A B C) (evalrsdbb1in A B C) :guard (>= C A))
(rule (evalrsdbb4in A B C) (evalrsdreturnin A B C) :guard (>= A (+ C 1)))
(rule
  (evalrsdbb1in A B C)
  (evalrsdbb2in A B C)
  :guard
  (exists ((D Int)) (>= 0 (+ D 1))))
(rule
  (evalrsdbb1in A B C)
  (evalrsdbb2in A B C)
  :guard
  (exists ((D Int)) (>= D 1)))
(rule (evalrsdbb1in A B C) (evalrsdbb3in A B C))
(rule (evalrsdbb2in A B C) (evalrsdbb4in A B (- C 1)))
(rule (evalrsdbb3in A B C) (evalrsdbb4in A (- B 1) (- B 1)))
(rule (evalrsdreturnin A B C) (evalrsdstop A B C))
