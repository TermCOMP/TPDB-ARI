(format LCTRS)
(theory Ints)
(fun evalloopsbb1in (-> Int Int Int))
(fun evalloopsbb3in (-> Int Int Int))
(fun evalloopsbb4in (-> Int Int Int))
(fun evalloopsbb5in (-> Int Int Int))
(fun evalloopsbb6in (-> Int Int Int))
(fun evalloopsentryin (-> Int Int Int))
(fun evalloopsreturnin (-> Int Int Int))
(fun evalloopsstart (-> Int Int Int))
(fun evalloopsstop (-> Int Int Int))
(entrypoint evalloopsstart)
(rule (evalloopsstart A B) (evalloopsentryin A B))
(rule (evalloopsentryin A B) (evalloopsbb6in A B) :guard (>= A 0))
(rule (evalloopsentryin A B) (evalloopsreturnin A B) :guard (>= 0 (+ A 1)))
(rule (evalloopsbb6in A B) (evalloopsbb1in A B) :guard (>= A 0))
(rule (evalloopsbb6in A B) (evalloopsreturnin A B) :guard (>= 0 (+ A 1)))
(rule (evalloopsbb1in A B) (evalloopsbb4in A 1) :guard (>= A 2))
(rule (evalloopsbb1in A B) (evalloopsbb5in A C) :guard (>= 1 A))
(rule (evalloopsbb4in A B) (evalloopsbb3in A B) :guard (>= A (+ B 1)))
(rule (evalloopsbb4in A B) (evalloopsbb5in A B) :guard (>= B A))
(rule (evalloopsbb3in A B) (evalloopsbb4in A (* 2 B)))
(rule (evalloopsbb5in A B) (evalloopsbb6in (- A 1) B))
(rule (evalloopsreturnin A B) (evalloopsstop A B))
