(format LCTRS)
(theory Ints)
(fun l0 (-> Int Int))
(fun l1 (-> Int Int))
(fun l2 (-> Int Int))
(fun l3 (-> Int Int))
(fun l4 (-> Int Int))
(fun l5 (-> Int Int))
(entrypoint l5)
(rule (l0 pc_Loop^0) (l1 pc_Loop^post) :guard (= pc_Loop^post 2))
(rule (l1 pc_Loop^0) (l0 pc_Loop^post) :guard (= pc_Loop^0 pc_Loop^post))
(rule
(l2 pc_Loop^0)
(l3 pc_Loop^post)
:guard
(exists ((pc_Loop^1 Int)) (and (= pc_Loop^1 3) (= pc_Loop^post 2))))
(rule (l3 pc_Loop^0) (l2 pc_Loop^post) :guard (= pc_Loop^0 pc_Loop^post))
(rule (l4 pc_Loop^0) (l2 pc_Loop^post) :guard (= pc_Loop^post 2))
(rule (l5 pc_Loop^0) (l4 pc_Loop^post) :guard (= pc_Loop^0 pc_Loop^post))
